# Copyright 2024 The HuggingFace Inc. team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Records a dataset. Actions for the robot can be either generated by teleoperation or by a policy.
THIS VERSION: replace teleop.get_action() with TCP-received action dict.
"""

import logging
import time
import json
import socket
from dataclasses import asdict, dataclass, field
from pathlib import Path
from pprint import pformat
from typing import Any, Optional

from lerobot.cameras import (  # noqa: F401
    CameraConfig,  # noqa: F401
)
from lerobot.cameras.opencv.configuration_opencv import OpenCVCameraConfig  # noqa: F401
from lerobot.cameras.realsense.configuration_realsense import RealSenseCameraConfig  # noqa: F401
from lerobot.configs import parser
from lerobot.configs.policies import PreTrainedConfig
from lerobot.datasets.image_writer import safe_stop_image_writer
from lerobot.datasets.lerobot_dataset import LeRobotDataset
from lerobot.datasets.pipeline_features import aggregate_pipeline_dataset_features, create_initial_features
from lerobot.datasets.utils import build_dataset_frame, combine_feature_dicts
from lerobot.datasets.video_utils import VideoEncodingManager
from lerobot.policies.factory import make_policy, make_pre_post_processors
from lerobot.policies.pretrained import PreTrainedPolicy
from lerobot.processor import (
    PolicyAction,
    PolicyProcessorPipeline,
    RobotAction,
    RobotObservation,
    RobotProcessorPipeline,
    make_default_processors,
)
from lerobot.processor.rename_processor import rename_stats
from lerobot.robots import (  # noqa: F401
    Robot,
    RobotConfig,
    bi_so100_follower,
    hope_jr,
    koch_follower,
    make_robot_from_config,
    so100_follower,
    so101_follower,
)
from lerobot.teleoperators import (  # noqa: F401
    Teleoperator,
    TeleoperatorConfig,
    bi_so100_leader,
    homunculus,
    koch_leader,
    make_teleoperator_from_config,
    so100_leader,
    so101_leader,
)
from lerobot.teleoperators.keyboard.teleop_keyboard import KeyboardTeleop
from lerobot.utils.constants import ACTION, OBS_STR
from lerobot.utils.control_utils import (
    init_keyboard_listener,
    is_headless,
    predict_action,
    sanity_check_dataset_name,
    sanity_check_dataset_robot_compatibility,
    init_ros2_listener,
)
from lerobot.utils.import_utils import register_third_party_devices
from lerobot.utils.robot_utils import busy_wait
from lerobot.utils.utils import (
    get_safe_torch_device,
    init_logging,
    log_say,
)
from lerobot.utils.visualization_utils import init_rerun, log_rerun_data

import rclpy
from rclpy.node import Node

class RecordControlNode(Node):
    def __init__(self):
        super().__init__("record_control_node")
# =========================
# TCP Action Receiver
# =========================
class TCPActionReceiver:
    def __init__(self, host, port, timeout_s=5.0):
        self.host = host
        self.port = port
        self.timeout_s = timeout_s

        self.latest_action = None
        self.latest_ts = 0.0
        self._running = False

    def connect(self):
        logging.info(f"üîå [TCP-ACTION] Connecting to {self.host}:{self.port}")
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(self.timeout_s)
        s.connect((self.host, self.port))
        s.settimeout(None)

        self._sock = s
        self._file = s.makefile("r", encoding="utf-8", newline="\n")
        self._running = True

        import threading
        threading.Thread(target=self._recv_loop, daemon=True).start()
        logging.info("‚úÖ [TCP-ACTION] Connected")

    def _recv_loop(self):
        while self._running:
            line = self._file.readline()
            if not line:
                break
            try:
                msg = json.loads(line)
                if isinstance(msg, dict):
                    self.latest_action = {k: float(v) for k, v in msg.items()}
                    self.latest_ts = time.perf_counter()
            except Exception:
                continue

    def get_latest_action(self):
        return self.latest_action

    def close(self):
        self._running = False
        try:
            self._file.close()
            self._sock.close()
        except Exception:
            pass



@dataclass
class DatasetRecordConfig:
    repo_id: str
    single_task: str
    root: str | Path | None = None
    fps: int = 30
    episode_time_s: int | float = 60
    reset_time_s: int | float = 60
    num_episodes: int = 50
    video: bool = True
    push_to_hub: bool = True
    private: bool = False
    tags: list[str] | None = None
    num_image_writer_processes: int = 0
    num_image_writer_threads_per_camera: int = 4
    video_encoding_batch_size: int = 1
    rename_map: dict[str, str] = field(default_factory=dict)

    def __post_init__(self):
        if self.single_task is None:
            raise ValueError("You need to provide a task as argument in `single_task`.")


@dataclass
class RecordConfig:
    robot: RobotConfig
    dataset: DatasetRecordConfig
    teleop: TeleoperatorConfig | None = None
    policy: PreTrainedConfig | None = None
    display_data: bool = False
    play_sounds: bool = True
    resume: bool = False

    # NEW: TCP action source
    tcp_action_host: str = "172.20.10.2"
    tcp_action_port: int = 9002
    tcp_action_timeout_s: float = 5.0

    def __post_init__(self):
        policy_path = parser.get_path_arg("policy")
        if policy_path:
            cli_overrides = parser.get_cli_overrides("policy")
            self.policy = PreTrainedConfig.from_pretrained(policy_path, cli_overrides=cli_overrides)
            self.policy.pretrained_path = policy_path

        # We keep original constraint for policy path usage etc.
        # But to allow TCP-control WITHOUT teleop/policy, we still need "a controller" logically.
        # Here we allow teleop None when TCP action is used.
        if self.teleop is None and self.policy is None:
            # allow: "TCP action controls robot"
            logging.info("‚ÑπÔ∏è No teleop/policy provided: using TCP action stream as controller.")

    @classmethod
    def __get_path_fields__(cls) -> list[str]:
        return ["policy"]

@safe_stop_image_writer
def record_loop(
    robot: Robot,
    events: dict,
    fps: int,
    teleop_action_processor,
    robot_action_processor,
    robot_observation_processor,
    events_lock,
    dataset: LeRobotDataset | None = None,
    teleop=None,
    policy=None,
    preprocessor=None,
    postprocessor=None,
    control_time_s: int | None = None,
    single_task: str | None = None,
    display_data: bool = False,
    tcp_receiver=None,
):
    start_episode_t = time.perf_counter()
    timestamp = 0.0

    while timestamp < control_time_s:
        loop_start = time.perf_counter()
        with events_lock:
            if events.get("exit_early", False):
                events["exit_early"] = False
                break

        # =========================
        # A. get_observation
        # =========================
        obs = robot.get_observation()
        obs_processed = robot_observation_processor(obs)

        # ===== ÊûÑÂª∫ observation_frameÔºàÂÆòÊñπ‰∏ÄËá¥Ôºâ=====
        observation_frame = None
        if dataset is not None:
            observation_frame = build_dataset_frame(
                dataset.features, obs_processed, prefix=OBS_STR
            )

        # =========================
        # B. get action (TCP)
        # =========================
        act = tcp_receiver.get_latest_action() if tcp_receiver else None
        if act is None:
            busy_wait(1.0 / fps)
            timestamp = time.perf_counter() - start_episode_t
            continue

        # =========================
        # C. processors
        # =========================
        act_processed = teleop_action_processor((act, obs))
        robot_action = robot_action_processor((act_processed, obs))

        # =========================
        # D. send to robot
        # =========================
        robot.send_action(robot_action)

        # =========================
        # E. dataset add_frameÔºà‚≠êÂÖ≥ÈîÆ‰øÆÂ§ç‚≠êÔºâ
        # =========================
        if dataset is not None:
            action_frame = build_dataset_frame(
                dataset.features, act_processed, prefix=ACTION
            )
            frame = {
                **observation_frame,
                **action_frame,
                "task": single_task,
            }
            dataset.add_frame(frame)

        # =========================
        # F. fps control
        # =========================
        dt = time.perf_counter() - loop_start
        busy_wait(max(0.0, 1.0 / fps - dt))
        timestamp = time.perf_counter() - start_episode_t



@parser.wrap()
def record(cfg: RecordConfig) -> LeRobotDataset:
    init_logging()
    logging.info(pformat(asdict(cfg)))
    if cfg.display_data:
        init_rerun(session_name="recording")

    robot = make_robot_from_config(cfg.robot)

    # teleop is now optional; we keep original creation but can be None
    teleop = make_teleoperator_from_config(cfg.teleop) if cfg.teleop is not None else None

    teleop_action_processor, robot_action_processor, robot_observation_processor = make_default_processors()

    dataset_features = combine_feature_dicts(
        aggregate_pipeline_dataset_features(
            pipeline=teleop_action_processor,
            initial_features=create_initial_features(action=robot.action_features),
            use_videos=cfg.dataset.video,
        ),
        aggregate_pipeline_dataset_features(
            pipeline=robot_observation_processor,
            initial_features=create_initial_features(observation=robot.observation_features),
            use_videos=cfg.dataset.video,
        ),
    )

    if cfg.resume:
        dataset = LeRobotDataset(
            cfg.dataset.repo_id,
            root=cfg.dataset.root,
            batch_encoding_size=cfg.dataset.video_encoding_batch_size,
        )

        if hasattr(robot, "cameras") and len(robot.cameras) > 0:
            dataset.start_image_writer(
                num_processes=cfg.dataset.num_image_writer_processes,
                num_threads=cfg.dataset.num_image_writer_threads_per_camera * len(robot.cameras),
            )
        sanity_check_dataset_robot_compatibility(dataset, robot, cfg.dataset.fps, dataset_features)
    else:
        sanity_check_dataset_name(cfg.dataset.repo_id, cfg.policy)
        dataset = LeRobotDataset.create(
            cfg.dataset.repo_id,
            cfg.dataset.fps,
            root=cfg.dataset.root,
            robot_type=robot.name,
            features=dataset_features,
            use_videos=cfg.dataset.video,
            image_writer_processes=cfg.dataset.num_image_writer_processes,
            image_writer_threads=cfg.dataset.num_image_writer_threads_per_camera * len(robot.cameras),
            batch_encoding_size=cfg.dataset.video_encoding_batch_size,
        )

    policy = None if cfg.policy is None else make_policy(cfg.policy, ds_meta=dataset.meta)
    preprocessor = None
    postprocessor = None
    if cfg.policy is not None:
        preprocessor, postprocessor = make_pre_post_processors(
            policy_cfg=cfg.policy,
            pretrained_path=cfg.policy.pretrained_path,
            dataset_stats=rename_stats(dataset.meta.stats, cfg.dataset.rename_map),
            preprocessor_overrides={
                "device_processor": {"device": cfg.policy.device},
                "rename_observations_processor": {"rename_map": cfg.dataset.rename_map},
            },
        )

    # NEW: TCP receiver
    tcp_receiver = None
    if policy is None:
        tcp_receiver = TCPActionReceiver(
            host=cfg.tcp_action_host,
            port=cfg.tcp_action_port,
            timeout_s=cfg.tcp_action_timeout_s,
        )
        tcp_receiver.connect()

    robot.connect()
    # if hasattr(robot, "cameras"):
    #     import types, time

    #     for k, cam in robot.cameras.items():
    #         if hasattr(cam, "async_read"):
    #             orig = cam.async_read

    #             def wrap_async_read(self, *args, __k=k, __orig=orig, **kwargs):
    #                 t0 = time.perf_counter()
    #                 out = __orig(*args, **kwargs)
    #                 t1 = time.perf_counter()
    #                 print(f"[TIMING] cam[{__k}].async_read: {(t1-t0)*1000:.2f} ms")
    #                 return out

    #             cam.async_read = types.MethodType(wrap_async_read, cam)
    if teleop is not None:
        teleop.connect()

    # listener, events = init_keyboard_listener()
    rclpy.init(args=None)
    control_node = RecordControlNode()

    listener, events, events_lock = init_ros2_listener(control_node, "/record_control")

    # ÂÜçËµ∑‰∏Ä‰∏™ spin Á∫øÁ®ãÔºå‰∏çÈòªÂ°û‰∏ªÂΩïÂà∂Âæ™ÁéØ
    import threading
    spin_thread = threading.Thread(target=rclpy.spin, args=(control_node,), daemon=True)
    spin_thread.start()
    try:
        with VideoEncodingManager(dataset):
            recorded_episodes = 0
            while recorded_episodes < cfg.dataset.num_episodes and not events["stop_recording"]:
                log_say(f"Recording episode {dataset.num_episodes}", cfg.play_sounds)
                record_loop(
                    robot=robot,
                    events=events,
                    fps=cfg.dataset.fps,
                    teleop_action_processor=teleop_action_processor,
                    robot_action_processor=robot_action_processor,
                    robot_observation_processor=robot_observation_processor,
                    events_lock=events_lock,
                    teleop=teleop,
                    policy=policy,
                    preprocessor=preprocessor,
                    postprocessor=postprocessor,
                    dataset=dataset,
                    control_time_s=cfg.dataset.episode_time_s,
                    single_task=cfg.dataset.single_task,
                    display_data=cfg.display_data,
                    tcp_receiver=tcp_receiver,
                )

                if not events["stop_recording"] and (
                    (recorded_episodes < cfg.dataset.num_episodes - 1) or events["rerecord_episode"]
                ):
                    log_say("Reset the environment", cfg.play_sounds)
                    record_loop(
                        robot=robot,
                        events=events,
                        fps=cfg.dataset.fps,
                        teleop_action_processor=teleop_action_processor,
                        robot_action_processor=robot_action_processor,
                        robot_observation_processor=robot_observation_processor,
                        events_lock=events_lock,
                        teleop=teleop,
                        control_time_s=cfg.dataset.reset_time_s,
                        single_task=cfg.dataset.single_task,
                        display_data=cfg.display_data,
                        tcp_receiver=tcp_receiver,
                    )

                if events["rerecord_episode"]:
                    log_say("Re-record episode", cfg.play_sounds)
                    events["rerecord_episode"] = False
                    events["exit_early"] = False
                    dataset.clear_episode_buffer()
                    continue

                dataset.save_episode()
                recorded_episodes += 1

        log_say("Stop recording", cfg.play_sounds, blocking=True)

    finally:
        robot.disconnect()
        if teleop is not None:
            teleop.disconnect()

        if tcp_receiver is not None:
            tcp_receiver.close()

        #if not is_headless() and listener is not None:
        #    listener.stop()
        try:
            control_node.destroy_node()
            rclpy.shutdown()
        except Exception:
            pass

    if cfg.dataset.push_to_hub:
        dataset.push_to_hub(tags=cfg.dataset.tags, private=cfg.dataset.private)

    log_say("Exiting", cfg.play_sounds)
    return dataset


def main():
    register_third_party_devices()
    record()


if __name__ == "__main__":
    main()
